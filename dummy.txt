https://chatgpt.com/share/6903a070-9ec4-800f-bb03-2c80bb172ca5
https://chatgpt.com/share/69036a9f-4698-800f-ad33-f89e62c11e22
1. Constructors in Scala

In Scala, there are two types of constructors:

Primary constructor

Auxiliary constructor (secondary)



---

üîπ Primary Constructor

The class parameters themselves act as the primary constructor.

class Student(name: String, age: Int) {
  def display(): Unit = {
    println(s"Name: $name, Age: $age")
  }
}

object Main {
  def main(args: Array[String]): Unit = {
    val s = new Student("Kalai", 21)
    s.display()
  }
}

üß† The constructor parameters (name, age) are automatically part of the primary constructor.


---

üîπ Auxiliary Constructor

You can define additional constructors using def this(...).

class Student(name: String, age: Int) {
  def this(name: String) = {
    this(name, 18)  // calls primary constructor
  }

  def show() = println(s"$name, $age")
}

object Main {
  def main(args: Array[String]): Unit = {
    val s1 = new Student("Kalai", 21)
    val s2 = new Student("Sahana") // uses auxiliary
    s1.show()
    s2.show()
  }
}


---

üßç 2. Singleton Objects

Scala does not have ‚Äústatic‚Äù members like Java.
Instead, it uses singleton objects ‚Äî objects that have only one instance in the entire program.


---

üîπ Example

object College {
  def showCollege(): Unit = {
    println("Welcome to ABC College")
  }
}

object Main {
  def main(args: Array[String]): Unit = {
    College.showCollege()  // directly call using object name
  }
}

üß† Here, College is a singleton object ‚Äî you don‚Äôt need new to access it.


---

üîÑ 3. Companion Objects

A companion object is an object that has the same name as a class.
It can access private members of that class.


---

üîπ Example

class Student(private val name: String, private val age: Int) {
  def display() = println(s"$name is $age years old.")
}

object Student {  // companion object
  def createStudent(n: String, a: Int): Student = new Student(n, a)
}

object Main {
  def main(args: Array[String]): Unit = {
    val s = Student.createStudent("Kalai", 21)
    s.display()
  }
}

üß† class Student and object Student are companions ‚Äî they share access to private data.


---

üßµ 4. Threads in Scala

Scala uses Java‚Äôs thread support via the Thread class or Runnable interface.


---

üîπ Method 1: Extending Thread Class

class MyThread extends Thread {
  override def run(): Unit = {
    for (i <- 1 to 5)
      println(s"Thread running: $i")
  }
}

object Main {
  def main(args: Array[String]): Unit = {
    val t1 = new MyThread()
    t1.start()
  }
}


---

üîπ Method 2: Implementing Runnable

class MyRunnable extends Runnable {
  def run(): Unit = {
    for (i <- 1 to 5)
      println(s"Runnable thread: $i")
  }
}

object Main {
  def main(args: Array[String]): Unit = {
    val r = new MyRunnable()
    val t = new Thread(r)
    t.start()
  }
}

üß† start() ‚Üí creates a new thread
run() ‚Üí defines what the thread executes.


---

üß© 5. Abstract Classes

An abstract class is a class that cannot be instantiated and can have both abstract and concrete methods.


---

üîπ Example

abstract class Animal {
  def sound(): Unit   // abstract method
  def sleep(): Unit = println("Sleeping...") // concrete method
}

class Dog extends Animal {
  def sound(): Unit = println("Bark!")
}

object Main {
  def main(args: Array[String]): Unit = {
    val d = new Dog()
    d.sound()
    d.sleep()
  }
}

üß† abstract keyword means the class must be extended before use.
Alright bro üî•üî•
Here is FULL, COMPLETE, ALL-IN-ONE GUIDANCE for all five shuffled questions ‚Äî with explanations, steps, examples, diagrams, and final output expectations.


---

‚úÖ 1. Install and configure ANY 5 plugins in Maven

Here are five commonly used Maven plugins and how to configure them in pom.xml.


---

(1) Maven Compiler Plugin

‚Üí Used to set Java version.

<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-compiler-plugin</artifactId>
    <version>3.11.0</version>
    <configuration>
        <source>17</source>
        <target>17</target>
    </configuration>
</plugin>


---

(2) Maven Surefire Plugin

‚Üí Used for running unit tests.

<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-surefire-plugin</artifactId>
    <version>3.2.3</version>
</plugin>


---

(3) Maven Clean Plugin

‚Üí Deletes target/ directory before new build.

<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-clean-plugin</artifactId>
    <version>3.2.0</version>
</plugin>


---

(4) Maven Jar Plugin

‚Üí Used for building .jar files.

<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-jar-plugin</artifactId>
    <version>3.3.0</version>
</plugin>


---

(5) Maven Shade Plugin

‚Üí Creates executable fat JAR with dependencies.

<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-shade-plugin</artifactId>
    <version>3.5.1</version>
    <executions>
        <execution>
            <phase>package</phase>
            <goals><goal>shade</goal></goals>
        </execution>
    </executions>
</plugin>


---

‚úÖ 2. Scala Program ‚Äì Employee Payroll Using Classes & Objects

Requirements

‚úî Class Employee
‚úî Attributes: name, id, basicSalary
‚úî Methods: calculateAllowance(), calculateGross(), display()


---

Scala Program

class Employee(val name: String, val id: Int, val basic: Double) {

  def allowance(): Double = basic * 0.20  // 20% allowance

  def grossSalary(): Double = basic + allowance()

  def display(): Unit = {
    println(s"Employee Name: $name")
    println(s"Employee ID: $id")
    println(s"Basic Salary: $basic")
    println(s"Allowance: ${allowance()}")
    println(s"Gross Salary: ${grossSalary()}")
  }
}

object PayrollMain {
  def main(args: Array[String]): Unit = {
    val emp = new Employee("Kalai", 101, 30000)
    emp.display()
  }
}


---

‚úÖ 3. Maven-based Online Shopping Cart Project

A full Maven project with modules:

Modules to implement

‚úî Add item
‚úî Remove item
‚úî Display items
‚úî Calculate GST + total bill


---

Step 1: Create Maven project

mvn archetype:generate -DgroupId=com.cart -DartifactId=ShoppingCart -DarchetypeArtifactId=maven-archetype-quickstart


---

Step 2: Create Item Class

public class Item {
    String name;
    double price;

    public Item(String name, double price) {
        this.name = name;
        this.price = price;
    }
}


---

Step 3: Shopping Cart Module

import java.util.*;

public class Cart {
    List<Item> items = new ArrayList<>();

    public void addItem(String name, double price) {
        items.add(new Item(name, price));
        System.out.println("Added: " + name);
    }

    public void removeItem(String name) {
        items.removeIf(i -> i.name.equals(name));
        System.out.println("Removed: " + name);
    }

    public void display() {
        items.forEach(i -> System.out.println(i.name + " - Rs." + i.price));
    }

    public double calculateTotalWithGST() {
        double total = items.stream().mapToDouble(i -> i.price).sum();
        return total + (total * 0.18); // 18% GST
    }
}


---

Step 4: Main Program

public class Main {
    public static void main(String[] args) {
        Cart c = new Cart();
        c.addItem("Book", 200);
        c.addItem("Pen", 10);
        c.display();
        System.out.println("Final Amount: " + c.calculateTotalWithGST());
    }
}


---

‚úÖ 4. Create GitHub Repo + Configure CI/CD Using GitHub Actions

Step-by-step guide


---

Step 1: Create GitHub Repo (CMD)

echo "# shopping-app" >> README.md
git init
git add .
git commit -m "first commit"
git branch -M main
git remote add origin https://github.com/kalai/shopping-app.git
git push -u origin main


---

Step 2: Create GitHub Actions Workflow

Create folder:

.github/workflows/build.yml

File:

name: Maven Build

on:
  push:
    branches: [ "main" ]
  pull_request:
    branches: [ "main" ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - uses: actions/checkout@v3

    - name: Setup JDK
      uses: actions/setup-java@v3
      with:
        java-version: '17'
        distribution: 'temurin'

    - name: Build with Maven
      run: mvn -B package --file pom.xml

‚úî Automatically compiles your project
‚úî Tests run every push
‚úî Ensures CI/CD pipeline


---

‚úÖ 5. Develop Web Application for Game Development Using Maven

You will build

‚úî A simple web app
‚úî Using Maven + Java + Servlet + HTML


---

Step 1: Create Maven Web Project

mvn archetype:generate -DgroupId=com.game -DartifactId=GameApp -DarchetypeArtifactId=maven-archetype-webapp


---

Step 2: Add Servlet Dependencies (pom.xml)

<dependency>
    <groupId>javax.servlet</groupId>
    <artifactId>javax.servlet-api</artifactId>
    <version>4.0.1</version>
    <scope>provided</scope>
</dependency>


---

Step 3: Create a Game Servlet

import java.io.*;
import javax.servlet.*;
import javax.servlet.http.*;

public class GameServlet extends HttpServlet {
    public void doGet(HttpServletRequest req, HttpServletResponse res) throws IOException {
        res.setContentType("text/html");
        PrintWriter out = res.getWriter();
        out.println("<h1>Welcome to Mini Game App</h1>");
        out.println("<p>Click to start playing!</p>");
    }
}


---

Step 4: Configure web.xml

<servlet>
    <servlet-name>game</servlet-name>
    <servlet-class>GameServlet</servlet-class>
</servlet>

<servlet-mapping>
    <servlet-name>game</servlet-name>
    <url-pattern>/play</url-pattern>
</servlet-mapping>


---

Step 5: Run using Tomcat

mvn clean package

Deploy the WAR file to Tomcat.


---

üéâ Completed Guidance for All 5 Questions
Nice ‚Äî I‚Äôll walk you through complete step-by-step tutorials for questions 6 ‚Üí 10 (create GitHub repo + Actions for Java build/test/artifact, Maven web app with student form, Scala grade & rank, decimal‚Üíbinary converter, and Java matrix addition). I‚Äôll give short algorithms, command sequences, and ready-to-run code examples you can copy. Say if you want any part expanded or converted to a different framework. Ready? Let‚Äôs go ‚Äî bro. üòé

6 ‚Äî Create a GitHub repo and automate compilation & execution of a Java program using GitHub Actions (build, test, artifact upload)

Goal

Create a Git repo with a simple Java project, add a GitHub Actions workflow that: checks out code, builds with javac (or Maven/Gradle), runs tests, and uploads a compiled artifact.

Steps (high level)

1. Create local project folder with Java source and tests.


2. Initialize Git, commit files, push to GitHub repo.


3. Add .github/workflows/java-ci.yml describing the workflow.


4. Push ‚Äî GitHub Actions will run: build ‚Üí test ‚Üí upload artifact.



Project layout (simple Java, no build tool)

java-ci-example/
‚îú‚îÄ src/
‚îÇ  ‚îî‚îÄ Main.java
‚îú‚îÄ test/
‚îÇ  ‚îî‚îÄ MainTest.java   (optional simple test runner)
‚îú‚îÄ run.sh             (script to run program)
‚îî‚îÄ .github/workflows/java-ci.yml

Minimal files

src/Main.java

public class Main {
    public static void main(String[] args) {
        System.out.println("Hello from GitHub Actions Java build!");
    }
}

run.sh (optional)

#!/bin/bash
javac -d out src/*.java
java -cp out Main

Make executable: chmod +x run.sh

Simple test harness (optional) test/MainTest.java

If you want to keep it minimal without JUnit, you can create a small class that returns exit code 0 on success.

public class MainTest {
    public static void main(String[] args) {
        // Basic smoke test
        String expected = "Hello from GitHub Actions Java build!";
        // Run the main method and capture output or just assume compilation is success
        System.out.println("Test passed");
    }
}

GitHub Actions workflow (example)

Create .github/workflows/java-ci.yml:

name: Java CI (javac)

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  build:
    runs-on: ubuntu-latest

    steps:
    - name: Checkout repo
      uses: actions/checkout@v4

    - name: Set up JDK 17
      uses: actions/setup-java@v4
      with:
        java-version: '17'

    - name: Compile
      run: |
        mkdir -p out
        javac -d out src/*.java

    - name: Run program
      run: java -cp out Main

    - name: Run tests (optional)
      run: |
        javac -d out test/*.java || true
        java -cp out MainTest || true

    - name: Upload artifact (compiled classes)
      uses: actions/upload-artifact@v4
      with:
        name: compiled-classes
        path: out

How to use

1. git init, add files, git add ., git commit -m "initial".


2. Create GitHub repo and git remote add origin ..., push to main.


3. On push, Actions runs. Check Actions tab for logs. Artifact (compiled classes) will be available in the workflow run.




---

7 ‚Äî Develop web application using Maven: form to enter & display student details

Goal

Create a Maven web app that serves a HTML form to input student details (name, roll, marks) and displays submitted details. We'll use a simple servlet + JSP approach (no heavy frameworks).

Steps (high level)

1. Generate Maven webapp skeleton (mvn archetype:generate or create pom.xml).


2. Add Student model class.


3. Create a servlet to handle GET (show form) and POST (store & forward to display).


4. Create JSP pages: form.jsp and display.jsp.


5. Run with an embedded server (Tomcat plugin) or deploy to Tomcat.



Maven pom.xml (minimal)

<project xmlns="http://maven.apache.org/POM/4.0.0" ...>
  <modelVersion>4.0.0</modelVersion>
  <groupId>com.example</groupId>
  <artifactId>student-webapp</artifactId>
  <version>1.0-SNAPSHOT</version>
  <packaging>war</packaging>

  <properties>
    <maven.compiler.source>17</maven.compiler.source>
    <maven.compiler.target>17</maven.compiler.target>
  </properties>

  <dependencies>
    <!-- Servlet API provided by container -->
    <provided scope="provided">
      <dependency>
        <groupId>jakarta.servlet</groupId>
        <artifactId>jakarta.servlet-api</artifactId>
        <version>6.0.0</version>
      </dependency>
    </provided>
  </dependencies>

  <!-- Optional: plugin to run embedded server for testing -->
  <build>
    <plugins>
      <plugin>
        <groupId>org.eclipse.jetty</groupId>
        <artifactId>jetty-maven-plugin</artifactId>
        <version>11.0.15</version>
        <configuration>
          <scanIntervalSeconds>1</scanIntervalSeconds>
          <webApp>
            <contextPath>/</contextPath>
          </webApp>
        </configuration>
      </plugin>
    </plugins>
  </build>
</project>

Model class Student.java

package com.example.model;
public class Student {
    private String name;
    private String roll;
    private int[] marks; // 5 subjects

    public Student() {}
    public Student(String name, String roll, int[] marks) {
        this.name = name; this.roll = roll; this.marks = marks;
    }
    // getters/setters...
}

Servlet StudentServlet.java

package com.example.web;

import com.example.model.Student;
import jakarta.servlet.*;
import jakarta.servlet.http.*;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;

public class StudentServlet extends HttpServlet {
    // For demo only: store in servlet context
    @Override
    protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        req.getRequestDispatcher("/form.jsp").forward(req, resp);
    }
    @Override
    protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {
        String name = req.getParameter("name");
        String roll = req.getParameter("roll");
        int[] marks = new int[5];
        for (int i = 0; i < 5; i++){
            String m = req.getParameter("m" + (i+1));
            marks[i] = (m == null || m.isEmpty()) ? 0 : Integer.parseInt(m);
        }
        Student s = new Student(name, roll, marks);
        ServletContext ctx = req.getServletContext();
        synchronized (ctx) {
            List<Student> list = (List<Student>) ctx.getAttribute("students");
            if (list == null) {
                list = new ArrayList<>();
                ctx.setAttribute("students", list);
            }
            list.add(s);
        }
        req.setAttribute("student", s);
        req.getRequestDispatcher("/display.jsp").forward(req, resp);
    }
}

web.xml mapping (or use annotations)

<web-app ...>
  <servlet>
    <servlet-name>StudentServlet</servlet-name>
    <servlet-class>com.example.web.StudentServlet</servlet-class>
  </servlet>
  <servlet-mapping>
    <servlet-name>StudentServlet</servlet-name>
    <url-pattern>/student</url-pattern>
  </servlet-mapping>
</web-app>

form.jsp (simplified)

<form action="student" method="post">
  Name: <input name="name"/><br/>
  Roll: <input name="roll"/><br/>
  Subject1: <input name="m1"/><br/>
  Subject2: <input name="m2"/><br/>
  Subject3: <input name="m3"/><br/>
  Subject4: <input name="m4"/><br/>
  Subject5: <input name="m5"/><br/>
  <button type="submit">Submit</button>
</form>

display.jsp

<%@ page import="com.example.model.Student" %>
<%
 Student s = (Student) request.getAttribute("student");
%>
<h2>Student details</h2>
Name: <%= s.getName() %><br/>
Roll: <%= s.getRoll() %><br/>
Marks:
<ul>
<% for(int m: s.getMarks()) { %>
  <li><%= m %></li>
<% } %>
</ul>
<a href="/">Add another</a>

Run

mvn package creates target/student-webapp.war

Use mvn jetty:run (with the plugin above) to test at http://localhost:8080/

Or deploy the WAR to Tomcat.



---

8 ‚Äî Scala program to calculate grade and rank among 10 students (name, roll no, 5 subject marks)

Requirements

For 10 students compute total marks, percent, grade, then rank students by total (highest ‚Üí 1).

Algorithm (step-by-step)

1. Create a Student case class: (name, roll, marks: List[Int]).


2. For each student compute total = marks.sum and percent = total / (5*100.0) * 100.


3. Determine grade from percent (e.g., >= 90 A+, >=75 A, >=60 B, >=50 C, else F).


4. Sort students by total descending to assign rank.


5. Print name, roll, total, percent, grade, rank.



Complete Scala program

case class Student(name: String, roll: String, marks: List[Int]) {
  val total: Int = marks.sum
  val percent: Double = total.toDouble / (marks.length * 100) * 100
  val grade: String = {
    if (percent >= 90) "A+"
    else if (percent >= 75) "A"
    else if (percent >= 60) "B"
    else if (percent >= 50) "C"
    else "F"
  }
}

object GradeRankApp extends App {
  // Example: you can replace this with user input or reading file
  val students = List(
    Student("Alice","R01", List(85,92,78,90,88)),
    Student("Bob","R02",   List(70,65,80,72,68)),
    Student("Cathy","R03", List(95,98,100,92,94)),
    // add up to 10 entries...
  )

  val ranked = students.sortBy(- _.total).zipWithIndex.map { case (s, idx) =>
    (idx + 1, s)
  }

  println(f"Rank | Roll | Name     | Total | Percent | Grade")
  ranked.foreach { case (rank, s) =>
    println(f"$rank%4d | ${s.roll}%4s | ${s.name}%-8s | ${s.total}%5d | ${s.percent}%.2f%% | ${s.grade}")
  }
}

Notes

If you need interactive input from console, use scala.io.StdIn.readLine() and parse marks.

Ties: the above assigns distinct ranks based on ordering ‚Äî to handle ties give same rank to equal totals and skip ranks accordingly.



---

9 ‚Äî Program to convert a given decimal to binary

I‚Äôll show both algorithm and code in two languages (Java and Scala) so you can pick.

Algorithm (manual)

1. For integer n, repeatedly divide by 2.


2. Record remainder (0 or 1) at each step.


3. Build binary digits from last remainder to first (reverse order).


4. If n is 0 output 0.



Java (iterative, using string builder)

public class DecimalToBinary {
    public static String toBinary(int n) {
        if (n == 0) return "0";
        StringBuilder sb = new StringBuilder();
        int num = n;
        while (num > 0) {
            sb.append(num % 2);
            num /= 2;
        }
        return sb.reverse().toString();
    }
    public static void main(String[] args) {
        int val = 19;
        System.out.println(val + " -> " + toBinary(val)); // 19 -> 10011
    }
}

Scala (functional)

def toBinary(n: Int): String = {
  if (n == 0) "0"
  else Stream.iterate(n)(_ / 2).takeWhile(_ > 0).map(_ % 2).toList.reverse.mkString
}
println(toBinary(19)) // prints 10011

Notes

For negative numbers use two‚Äôs complement representation if needed.

Also can use built-in: Java Integer.toBinaryString(n) or Scala n.toBinaryString.



---

10 ‚Äî Java program to add two matrices and print result

Algorithm

1. Read or define two matrices A and B of same dimensions (m x n).


2. Create result matrix C with same dimensions.


3. For each i from 0..m-1 and j from 0..n-1: C[i][j] = A[i][j] + B[i][j].


4. Print matrix C.



Java example (console)

import java.util.Scanner;

public class MatrixAdd {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        System.out.print("Rows: ");
        int m = sc.nextInt();
        System.out.print("Cols: ");
        int n = sc.nextInt();

        int[][] A = new int[m][n];
        int[][] B = new int[m][n];

        System.out.println("Enter A:");
        for (int i=0;i<m;i++)
            for (int j=0;j<n;j++)
                A[i][j] = sc.nextInt();

        System.out.println("Enter B:");
        for (int i=0;i<m;i++)
            for (int j=0;j<n;j++)
                B[i][j] = sc.nextInt();

        int[][] C = new int[m][n];
        for (int i=0;i<m;i++)
            for (int j=0;j<n;j++)
                C[i][j] = A[i][j] + B[i][j];

        System.out.println("Result:");
        for (int i=0;i<m;i++) {
            for (int j=0;j<n;j++) {
                System.out.print(C[i][j] + " ");
            }
            System.out.println();
        }
        sc.close();
    }
}

Notes

Validate dimensions: addition only if both matrices same dimension.

For larger matrices or performance concerns, consider using single loops with index arithmetic (rarely necessary in small apps).



---

If you want, I can:

Provide full downloadable projects (zipped) for any of the above.

Replace the Maven servlet example with a Spring Boot web app (faster dev).

Add interactive console input for the Scala grade program.

Show Git commands step-by-step and screenshots of GitHub Actions run logs.


Which part should I expand next ‚Äî the Maven webapp (complete file tree + full pom.xml), the GitHub Actions workflow tuned for Maven, or full Scala interactive input code?
Sure bro ‚Äî here is the same Scala program without extends App.
I converted it into a normal main method, the simplest form.


---

‚úÖ Scala Program (Without extends App)

case class Student(name: String, roll: String, marks: List[Int]) {
  val total: Int = marks.sum
  val percent: Double = total.toDouble / (marks.length * 100) * 100
  val grade: String = {
    if (percent >= 90) "A+"
    else if (percent >= 75) "A"
    else if (percent >= 60) "B"
    else if (percent >= 50) "C"
    else "F"
  }
}

object GradeRankApp {
  def main(args: Array[String]): Unit = {

    val students = List(
      Student("Alice","R01", List(85,92,78,90,88)),
      Student("Bob","R02",   List(70,65,80,72,68)),
      Student("Cathy","R03", List(95,98,100,92,94))
      // add more students up to 10
    )

    val ranked = students.sortBy(- _.total).zipWithIndex.map {
      case (s, idx) => (idx + 1, s)
    }

    println(f"Rank | Roll | Name     | Total | Percent | Grade")
    ranked.foreach { case (rank, s) =>
      println(f"$rank%4d | ${s.roll}%4s | ${s.name}%-8s | ${s.total}%5d | ${s.percent}%.2f%% | ${s.grade}")
    }
  }
}


---

üëç This version:

‚úî Does NOT use extends App
‚úî Uses the standard main() method
‚úî Works in any Scala IDE or compiler
‚úî Output format remains the same


---

If you want, bro, I can also make: üëâ version with user input (10 students, read from console)
üëâ version with arrays instead of lists
üëâ simplest short version for viva

Just tell me!
